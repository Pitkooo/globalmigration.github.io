<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Globale Migration</title>
</head>
<body>
    <script src="js/three.min.js"></script>
    <script src="js/WebGL.js"></script>
    <script src="js/TrackballControls.js"></script>
    <script src="js/stats.min.js"></script>
    <script>
        var scene, renderer, camera;
	var mEarth, mGDP;	
	var controls;
	var stats;
	var mEarthMaterial, physical_texture;
	var textureLoader;
	var mDirectionallight;
	
	var pointStart, pointEnd, newArc1;
        function initialize() {
		renderer = new THREE.WebGLRenderer( {antialias: true, alpha:true} );
		renderer.setClearColor( "#0339fc", 0 ); // the default
		renderer.setSize( window.innerWidth, window.innerHeight );
		renderer.setPixelRatio( window.devicePixelRatio );
		document.body.appendChild( renderer.domElement );
		
                scene = new THREE.Scene();
		camera = new THREE.PerspectiveCamera( 45, window.innerWidth/window.innerHeight, 0.1, 1000 );
		
		textureLoader = new THREE.TextureLoader();		
                physical_texture = textureLoader.load('media/earth_surface_2048.jpg');

                mEarthMaterial = new THREE.MeshPhongMaterial(
					{
						map: physical_texture,
						//normalMap: textureLoader.load("media/earth_normal_2048.png"),
						//specular: 0x222222,
						//shininess: 50,
						//specularMap: textureLoader.load("media/earth_specular_2048.jpg")
					}
				);
		var sphereRadius = 1;
                mEarth = new THREE.Mesh( new THREE.SphereGeometry( sphereRadius, 32, 32 ), mEarthMaterial );
                const material = new THREE.LineBasicMaterial({
			color: 0x0000ff
		});

                scene.add( mEarth );
		
		var mAmbientLight = new THREE.AmbientLight( 0x333333 );
		scene.add( mAmbientLight );
		
                mDirectionallight = new THREE.DirectionalLight( 0xBBBBBB );
		mDirectionallight.position.y = 5;
		mDirectionallight.position.z = 13;
		scene.add( mDirectionallight );
		
		pointStart = new THREE.Vector3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).normalize().multiplyScalar(sphereRadius);
		pointEnd = new THREE.Vector3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).normalize().multiplyScalar(sphereRadius);
		newArc1 = setArc3D(pointStart, pointEnd, 50, "lime", false);
		sphere.add(newArc1);
                camera.position.z = 5;
				
		stats = new Stats();
		stats.domElement.style.position = 'absolute';
		stats.domElement.style.top = '0px';
		stats.domElement.style.left = '0px';
		stats.domElement.style.zIndex = 100;
		document.body.appendChild( stats.domElement );
				
		controls = new THREE.TrackballControls( camera, renderer.domElement );
		controls.rotateSpeed = 1.0;
		controls.zoomSpeed = 1.2;
		controls.panSpeed = 0.8;
		controls.noZoom = false;
		controls.noPan = false;
		controls.dynamicDampingFactor = 0.3;
		controls.keys = [ 65 /*A*/, 83 /*S*/, 68 /*D*/ ];
						
		window.addEventListener( 'resize', onWindowResized, false );

                animate();
        }

        function animate() {
		controls.update();
		renderer.render( scene, camera );
		stats.update();
		requestAnimationFrame( animate );
	}

	if ( THREE.WEBGL.isWebGLAvailable() == false )
		document.body.appendChild( THREE.WEBGL.getWebGLErrorMessage() );
	else
		initialize();	
	  
	function onWindowResized() {
		renderer.setSize( window.innerWidth, window.innerHeight );
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();		
		controls.handleResize();
	}
	    
	function setArc3D(pointStart, pointEnd, smoothness, color, clockWise) {
		  // calculate a normal ( taken from Geometry().computeFaceNormals() )
		  var cb = new THREE.Vector3(), ab = new THREE.Vector3(), normal = new THREE.Vector3();
		  cb.subVectors(new THREE.Vector3(), pointEnd);
		  ab.subVectors(pointStart, pointEnd);
		  cb.cross(ab);
		  normal.copy(cb).normalize();


		  var angle = pointStart.angleTo(pointEnd); // get the angle between vectors
		  if (clockWise) angle = angle - Math.PI * 2;  // if clockWise is true, then we'll go the longest path
		  var angleDelta = angle / (smoothness - 1); // increment
		
		//var geometry = new THREE.Geometry();
		  var pts = [];
		  for (var i = 0; i < smoothness; i++) {
		    pts.push(pointStart.clone().applyAxisAngle(normal, angleDelta * i))
		  }
		  var geometry = new THREE.BufferGeometry().setFromPoints(pts);

		  var arc = new THREE.Line(geometry, new THREE.LineBasicMaterial({
		    color: color
		  }));
		  return arc;
	
		}
    </script>
</body>
</html>
