<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

    <title>Globale Migration</title>
	<style>
		canvas	{
			width: 100%;
			height: 100%
		}
		body	{
			background-color: #000;
			margin: 0px;
			overflow: hidden;
		}
		
				</style>
</head>
<body>

    <script src="js/three.min.js"></script>
    <script src="js/WebGL.js"></script>
    <script src="js/TrackballControls.js"></script>
    <script src="js/stats.min.js"></script>
	<script src="js/three.MeshLine.js"></script>
	<script src="js/sweetalert.min.js"></script>
	
    <script>
	
    var scene, renderer, camera;
	var mEarth, mGDP;	
	var controls;
	var stats;
	var mEarthMaterial, physical_texture;
	var textureLoader;
	var mDirectionallight;
	var raycaster = new THREE.Raycaster();
	var mousePos = new THREE.Vector2();
	var group = new THREE.Group();
	var pointStart, pointEnd, newArc1, color;
	var sphereRadius = 1;	
    function initialize() {
		renderer = new THREE.WebGLRenderer( {antialias: true, alpha:true} );
		//renderer.setClearColor( "#0339fc", 0 ); // the default
		renderer.setSize( window.innerWidth, window.innerHeight );
		renderer.setPixelRatio( window.devicePixelRatio );
		document.body.appendChild( renderer.domElement );
		
        scene = new THREE.Scene();
		camera = new THREE.PerspectiveCamera( 45, window.innerWidth/window.innerHeight, 0.1, 1000 );
		
		textureLoader = new THREE.TextureLoader();		
        physical_texture = textureLoader.load('media/earth_surface_2048.jpg');
		region_texture = textureLoader.load('media/regionmap.png');
                mEarthMaterial = new THREE.MeshPhongMaterial(
					{
						map: region_texture,
						opacity: 0.5,
						transparent:true
						//normalMap: textureLoader.load("media/earth_normal_2048.png"),
						//specular: 0x222222,
						//shininess: 50,
						//specularMap: textureLoader.load("media/earth_specular_2048.jpg")
					}
				);
		
        mEarth = new THREE.Mesh( new THREE.SphereGeometry( sphereRadius, 32, 32 ), mEarthMaterial );
           

        scene.add( mEarth );
		
		var mAmbientLight = new THREE.AmbientLight( 0x333333 );
		scene.add( mAmbientLight );
		
        mDirectionallight = new THREE.DirectionalLight( 0xBBBBBB );
		mDirectionallight.position.y = 5;
		mDirectionallight.position.z = 13;
		scene.add( mDirectionallight );
		
		//Linien der Migrationsstr√∂me zwischen den Regionen
		var migration = [
				{ name: "Europa - Nordafrika", longitude: 25, latitude: 14, anzahl: 1000},
				{ name: "Europa - Nordamerika", longitude: 35, latitude: -100, anzahl: 5000},
		]
		pointStart = latlong2xyz(sphereRadius,48, 16); //immer gleich
		
		/*color = "lime"
		pointEnd = latlong2xyz(sphereRadius,migration[0].longitude, migration[0].latitude);
		newArc1 = setArc3D(pointStart, pointEnd, 150, "lime", false,migration[0].anzahl,migration[0].name);
		
		pointEnd2 = latlong2xyz(sphereRadius,migration[0].longitude, migration[0].latitude);
		newArc2 = setArc3D(pointStart, pointEnd, 150, "lime", false,migration[0].anzahl,migration[0].name);*/
		
		for( var cur_region=0; cur_region < migration.length; cur_region++ ) {
					setArc3D(pointStart,migration[cur_region].longitude, migration[cur_region].latitude,
					 150,"lime",false,migration[cur_region].anzahl, migration[cur_region].name );
				}
		//var group = new THREE.Group();
		//group.add(newArc1);
		scene.add(group);

        camera.position.z = 5;
		
		stats = new Stats();
		stats.domElement.style.position = 'absolute';
		stats.domElement.style.top = '0px';
		stats.domElement.style.left = '0px';
		stats.domElement.style.zIndex = 100;
		document.body.appendChild( stats.domElement );
				
		controls = new THREE.TrackballControls( camera, renderer.domElement );
		controls.rotateSpeed = 1.0;
		controls.zoomSpeed = 1.2;
		controls.panSpeed = 0.8;
		controls.noZoom = false;
		controls.noPan = false;
		controls.dynamicDampingFactor = 0.3;
		controls.keys = [ 65 /*A*/, 83 /*S*/, 68 /*D*/ ];
		
		window.addEventListener( 'resize', onWindowResized, false );
		raycaster.params.Line.threshold = 0.1;
		document.addEventListener( 'mousedown', onDocumentMouseDown );
		document.addEventListener( 'mousemove', onDocumentMouseMove );

        animate();
        }

	
	function onDocumentMouseDown( event ) {
		//console.log( "pageX: " + event.pageX + " pageY: " + event.pageY + " window.innerWidth: " + window.innerWidth + " window.innerHeight: " + window.innerHeight );
		mousePos.x = ( event.pageX / window.innerWidth ) * 2 - 1;
		mousePos.y = - ( event.pageY / window.innerHeight ) * 2 + 1;
		
		//console.log( "mousePos.x: " + mousePos.x + " mousePos.y: " + mousePos.y );
		
		raycaster.setFromCamera( mousePos, camera );
		var intersects = raycaster.intersectObjects( group.children );
		// only if the ray intersects with an object
		if ( intersects.length > 0 ) {
		//show message-box with name of intersected object
			alert( intersects[ 0 ].object.name );
			//for all intersected objects, set color of line to red
			//intersects[0].object.material.color.set( 0xff0000 );
			intersects[0].object.material.opacity = 0.5;
			setTimeout(function () {
				intersects[0].object.material.opacity =  1.0;
			})
		} 
	}

	function onDocumentMouseMove(){
		mousePos.x = ( event.pageX / window.innerWidth ) * 2 - 1;
		mousePos.y = - ( event.pageY / window.innerHeight ) * 2 + 1;
	}


	function hoverLines(){
		raycaster.setFromCamera( mousePos, camera );
		var intersects = raycaster.intersectObjects( group.children );
		for ( var i = 0; i < intersects.length; i++ ) {
				intersects[ i ].object.material.transparent = true;
				intersects[ i ].object.material.opacity = 0.5;
				intersects[0].object.material.color.set( 0xff0000 );
				setTimeout(function () {
				intersects[0].object.material.opacity =  1.0;
				intersects[0].object.material.color.set( 'Lime' );
				
			})
			}
	}

	function onWindowResized() {
		renderer.setSize( window.innerWidth, window.innerHeight );
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();		
		controls.handleResize();
	}
	
	function latlong2xyz( radius, latitude, longitude ) {
		var x = radius * Math.cos( deg2rad( longitude )) * Math.cos( deg2rad( latitude ) );
		var z = radius * Math.sin( deg2rad( longitude ) ) * Math.cos( deg2rad( latitude ) );
		var y = radius * Math.sin( deg2rad( latitude ) );
		var vector = new THREE.Vector3( x, y, -z );
		return vector;
	}
			
	function deg2rad( degree ) {
		var radians = degree * Math.PI/180;
		return radians;
	}

	function setArc3D(pointStart, longEnd, latEnd, smoothness, color, clockWise, lineWidth,name) {
		  // calculate a normal ( taken from Geometry().computeFaceNormals() )
		  pointEnd = latlong2xyz(sphereRadius,longEnd, latEnd);
		  var cb = new THREE.Vector3(), ab = new THREE.Vector3(), normal = new THREE.Vector3();
		  cb.subVectors(new THREE.Vector3(), pointEnd);
		  ab.subVectors(pointStart, pointEnd);
		  cb.cross(ab);
		  normal.copy(cb).normalize();


		  var angle = pointStart.angleTo(pointEnd); // get the angle between vectors
		  if (clockWise) angle = angle - Math.PI * 2;  // if clockWise is true, then we'll go the longest path
		  var angleDelta = angle / (smoothness - 1); // increment
		
		//var geometry = new THREE.Geometry();
		var pts = [];
		 for (var i = 0; i < smoothness; i++) {
		    pts.push(pointStart.clone().applyAxisAngle(normal, angleDelta * i))
		  }
		 
		   
		  /*for (let j = 0; j < Math.PI; j += 2* Math.PI / 50) {
			pts.push(new THREE.Vector3(Math.cos(j), Math.sin(j), 0));
			}*/

		  var geometry = new THREE.BufferGeometry().setFromPoints(pts);
		  
		  lineWidth = lineWidth * 0.00001;
		  var line = new MeshLine()
		  line.setGeometry(geometry);
		  var arcMaterial = new MeshLineMaterial({
		    color: color,
			lineWidth : lineWidth
		  });
		  
		  const arc = new THREE.Mesh(line, arcMaterial);
		  arc.name = name;
		  arc.anzahl = lineWidth;
		  arc.raycast = MeshLineRaycast;
		  group.add( arc );
		  
		  //return arc;
	
		}

	function animate() {
		controls.update();
		hoverLines();
		renderer.render( scene, camera );
		stats.update();
		requestAnimationFrame( animate );
	}

	if ( THREE.WEBGL.isWebGLAvailable() == false )
		document.body.appendChild( THREE.WEBGL.getWebGLErrorMessage() );
	else
		initialize();
    </script>
</body>
</html>