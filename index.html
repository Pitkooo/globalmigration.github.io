<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Globale Migration</title>
</head>
<body>
    <script src="js/three.min.js"></script>
    <script src="js/WebGL.js"></script>
    <script src="js/TrackballControls.js"></script>
    <script src="js/stats.min.js"></script>
    <script>
        var scene, renderer, camera;
	var mEarth, mGDP;	
	var controls;
	var stats;
	var mEarthMaterial, physical_texture;
	var textureLoader;
	var mDirectionallight;
        function initialize() {
		renderer = new THREE.WebGLRenderer( {antialias: true, alpha:true} );
		renderer.setClearColor( "#0339fc", 0 ); // the default
		renderer.setSize( window.innerWidth, window.innerHeight );
		renderer.setPixelRatio( window.devicePixelRatio );
		document.body.appendChild( renderer.domElement );
		
                scene = new THREE.Scene();
		camera = new THREE.PerspectiveCamera( 45, window.innerWidth/window.innerHeight, 0.1, 1000 );
		
		textureLoader = new THREE.TextureLoader();		
                physical_texture = textureLoader.load('media/earth_surface_2048.jpg');

                mEarthMaterial = new THREE.MeshPhongMaterial(
					{
						map: physical_texture,
						//normalMap: textureLoader.load("media/earth_normal_2048.png"),
						//specular: 0x222222,
						//shininess: 50,
						//specularMap: textureLoader.load("media/earth_specular_2048.jpg")
					}
				);

                mEarth = new THREE.Mesh( new THREE.SphereGeometry( 1, 32, 32 ), mEarthMaterial );
                
                scene.add( mEarth );
		
		var mAmbientLight = new THREE.AmbientLight( 0x333333 );
		scene.add( mAmbientLight );
		
                mDirectionallight = new THREE.DirectionalLight( 0xBBBBBB );
		mDirectionallight.position.y = 5;
		mDirectionallight.position.z = 13;
		scene.add( mDirectionallight );

                camera.position.z = 5;
				
		stats = new Stats();
		stats.domElement.style.position = 'absolute';
		stats.domElement.style.top = '0px';
		stats.domElement.style.left = '0px';
		stats.domElement.style.zIndex = 100;
		document.body.appendChild( stats.domElement );
		
		var getPosition = function (longitude, latitude, radius) {
		    //Convert longitude and latitude to rad coordinates
		    var lg = THREE.Math.degToRad(longitude);
		    var lt = THREE.Math.degToRad(latitude);
		    var temp = radius * Math.cos(lt);
		    //Get x, y, Z coordinates
		    var x = temp * Math.sin(lg);
		    var y = radius * Math.sin(lt);
		    var z = temp * Math.cos(lg);
		    return {
			x: x,
			y: y,
			z: z
		    }
		}
		
		var addLine = function (v0, v3) {
		    var angle = (v0.angleTo(v3) * 180) / Math.PI;
		    var aLen = angle * 0.5 * (1 - angle / (Math.PI * earthBallSize * parseInt(earthBallSize / 10)));
		    var hLen = angle * angle * 1.2 * (1 - angle / (Math.PI * earthBallSize * parseInt(earthBallSize / 10)));
		    var p0 = new THREE.Vector3(0, 0, 0);
		    //Normal vector
		    var rayLine = new THREE.Ray(p0, getVCenter(v0.clone(), v3.clone()));
		    //Vertex coordinates
		    var vtop = rayLine.at(hLen / rayLine.at(1).distanceTo(p0));
		    //Control point coordinates
		    var v1 = getLenVcetor(v0.clone(), vtop, aLen);
		    var v2 = getLenVcetor(v3.clone(), vtop, aLen);
		    //Draw Bezier curve
		    var curve = new THREE.CubicBezierCurve3(v0, v1, v2, v3);
		    var geometry = new THREE.Geometry();
		    geometry.vertices = curve.getPoints(100);
		    var line = new MeshLine();
		    line.setGeometry(geometry);
		    var material = new MeshLineMaterial({
			color: metapLineColor,
			lineWidth: 0.1,
			transparent: true,
			opacity: 1
		    })
		    return {
			curve: curve,
			lineMesh: new THREE.Mesh(line.geometry, material)
		    }
		}
		
		var animateDots = [];
		//Line object collection
		var groupLines = new THREE.Group();
		// line
		marking.children.forEach(function (item) {
		    var line = addLine(marking.children[0].position, item.position);
		    groupLines.add(line.lineMesh);
		    animateDots.push(line.curve.getPoints(metapNum));
		})
		scene.add(groupLines);
		//A ball that slides on the line
		var aGroup = new THREE.Group();
		for (var i = 0; i < animateDots.length; i ++) {
		    for (var j = 0; j < markingNum; j ++) {
			var aGeo = new THREE.SphereGeometry(slideBallSize, 10, 10);
			var aMaterial = new THREE.MeshBasicMaterial({
			    color: slideBallColor,
			    transparent: true,
			    opacity: 1 - j * 0.02
			})
			var aMesh = new THREE.Mesh(aGeo, aMaterial);
			aGroup.add(aMesh);
		    }
		}
		var vIndex = 0;
		var firstBool = true;
		function animationLine () {
		    aGroup.children.forEach(function (elem, index) {
			var _index = parseInt(index / markingNum);
			var index2 = index - markingNum * _index;
			var _vIndex = 0;
			if (firstBool) {
			    _vIndex = vIndex - index2 % markingNum >= 0 ? vIndex - index2 % markingNum : 0;
			} else {
			    _vIndex = vIndex - index2 % markingNum >= 0 ? vIndex - index2 % markingNum : metapNum + vIndex - index2;
			}
			var v = animateDots[_index][_vIndex];
			elem.position.set(v.x, v.y, v.z);
		    })
		    vIndex ++;
		    if (vIndex > metapNum) {
			vIndex = 0;
		    }
		    if (vIndex == metapNum && firstBool) {
			firstBool = false;
		    }
		    requestAnimationFrame(animationLine);
		}
		scene.add(aGroup);
		controls = new THREE.TrackballControls( camera, renderer.domElement );
		controls.rotateSpeed = 1.0;
		controls.zoomSpeed = 1.2;
		controls.panSpeed = 0.8;
		controls.noZoom = false;
		controls.noPan = false;
		controls.dynamicDampingFactor = 0.3;
		controls.keys = [ 65 /*A*/, 83 /*S*/, 68 /*D*/ ];
				
				
		window.addEventListener( 'resize', onWindowResized, false );

                animate();
        }

        function animate() {
		controls.update();
		renderer.render( scene, camera );
		stats.update();
		requestAnimationFrame( animate );
	}

	if ( THREE.WEBGL.isWebGLAvailable() == false )
		document.body.appendChild( THREE.WEBGL.getWebGLErrorMessage() );
	else
		initialize();	
	  
	function onWindowResized() {
		renderer.setSize( window.innerWidth, window.innerHeight );
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();		
		controls.handleResize();
	}
    </script>
</body>
</html>
